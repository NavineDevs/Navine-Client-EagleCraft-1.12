<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Navine Client - EagleCraft 1.12</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', monospace; }
        body { background: #000000; overflow: hidden; width: 100%; height: 100vh; }
        
        #navine-loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000000; display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 10000;
        }
        
        .loader-logo {
            font-size: 64px; font-weight: 900;
            background: linear-gradient(to right, #4169e1, #7df9ff);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            margin-bottom: 10px; letter-spacing: 3px;
        }
        
        .loader-text {
            color: #7df9ff; font-size: 18px; margin-bottom: 30px; opacity: 0.8;
        }
        
        .loading-bar-container {
            width: 400px; height: 8px; background: #0a0a0a;
            border-radius: 4px; overflow: hidden; border: 2px solid #4169e1;
            box-shadow: 0 0 10px #4169e1;
        }
        
        .loading-bar { height: 100%; background: linear-gradient(90deg, #4169e1, #7df9ff); width: 0%; }
        
        #game-container {
            width: 100%; height: 100%; display: none; position: relative;
        }
        
        canvas { 
            width: 100%; height: 100%; display: block; 
            cursor: crosshair;
        }
        
        /* NAVINE CLIENT UI */
        #navine-ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 100; overflow: hidden;
        }
        
        /* HUD - BOTTOM LEFT */
        #navine-hud {
            position: absolute; bottom: 20px; left: 20px;
            background: rgba(0, 0, 0, 0.9); border: 2px solid #4169e1;
            border-radius: 12px; padding: 20px; min-width: 250px;
            pointer-events: all; box-shadow: 0 0 25px rgba(65, 105, 225, 0.7);
            backdrop-filter: blur(5px);
        }
        
        .navine-title {
            color: #7df9ff; font-size: 18px; font-weight: bold;
            margin-bottom: 15px; border-bottom: 2px solid #4169e1;
            padding-bottom: 8px; text-align: center; letter-spacing: 1px;
        }
        
        .navine-stat {
            display: flex; justify-content: space-between;
            margin: 10px 0; font-size: 15px; align-items: center;
        }
        
        .navine-label { color: #4169e1; font-weight: 600; }
        .navine-value { 
            color: #7df9ff; font-weight: bold; 
            background: rgba(65, 105, 225, 0.2); 
            padding: 3px 10px; border-radius: 4px;
            border: 1px solid #4169e1;
        }
        
        #hack-status {
            margin-top: 15px; padding-top: 15px;
            border-top: 2px solid rgba(65, 105, 225, 0.3);
            font-size: 13px; color: #7df9ff; text-align: center;
            min-height: 40px; display: flex; align-items: center;
            justify-content: center; font-style: italic;
        }
        
        /* CONTROL BUTTONS */
        #control-buttons {
            position: absolute; bottom: 20px; right: 20px;
            display: flex; gap: 15px; pointer-events: all;
        }
        
        .control-btn {
            background: rgba(0, 0, 0, 0.85); color: #7df9ff;
            border: 2px solid #4169e1; padding: 12px 25px;
            border-radius: 10px; cursor: pointer; font-size: 15px;
            font-weight: bold; transition: all 0.3s;
            min-width: 140px; text-align: center;
        }
        
        .control-btn:hover {
            background: #4169e1; color: #000000;
            box-shadow: 0 0 20px #7df9ff;
            transform: translateY(-2px);
        }
        
        /* HACK MENU */
        #hack-menu {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.97);
            border: 3px solid #4169e1; border-radius: 15px; padding: 25px;
            width: 450px; display: none; pointer-events: all;
            box-shadow: 0 0 50px rgba(125, 249, 255, 0.6);
            backdrop-filter: blur(10px);
        }
        
        .menu-title {
            color: #7df9ff; font-size: 26px; text-align: center;
            margin-bottom: 25px; border-bottom: 3px solid #4169e1;
            padding-bottom: 12px; letter-spacing: 2px;
        }
        
        .hack-category { 
            margin: 20px 0; 
            background: rgba(65, 105, 225, 0.05);
            border-radius: 10px; padding: 15px;
        }
        
        .category-title {
            color: #7df9ff; font-size: 18px; margin-bottom: 15px;
            padding-left: 10px; border-left: 4px solid #4169e1;
            font-weight: 600;
        }
        
        .hack-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 12px; margin: 10px 0; background: rgba(65, 105, 225, 0.1);
            border-radius: 8px; cursor: pointer; border: 1px solid transparent;
            transition: all 0.2s;
        }
        
        .hack-item:hover {
            background: rgba(65, 105, 225, 0.25); 
            border-color: #7df9ff;
            transform: translateX(5px);
        }
        
        .hack-name { 
            color: #4169e1; font-size: 16px; flex: 1; 
            font-weight: 600;
        }
        
        .hack-key {
            color: #7df9ff; background: rgba(0, 0, 0, 0.6);
            padding: 4px 10px; border-radius: 5px; font-size: 13px;
            margin-right: 15px; border: 1px solid #4169e1;
            font-weight: bold; min-width: 60px; text-align: center;
        }
        
        .hack-toggle {
            width: 50px; height: 26px; background: #0a0a0a;
            border-radius: 13px; border: 2px solid #4169e1;
            position: relative; cursor: pointer; transition: all 0.3s;
        }
        
        .hack-toggle.active {
            background: #4169e1; border-color: #7df9ff;
            box-shadow: 0 0 10px #7df9ff;
        }
        
        .hack-toggle::after {
            content: ''; position: absolute; top: 3px; left: 3px;
            width: 20px; height: 20px; background: #7df9ff; border-radius: 50%;
            transition: all 0.3s;
        }
        
        .hack-toggle.active::after {
            left: 27px; background: #000000;
            box-shadow: 0 0 5px #000000;
        }
        
        /* COMMAND WINDOW */
        #command-window {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.97);
            border: 3px solid #4169e1; border-radius: 15px; padding: 25px;
            width: 500px; display: none; pointer-events: all;
            box-shadow: 0 0 50px rgba(125, 249, 255, 0.6);
            backdrop-filter: blur(10px);
        }
        
        .command-header {
            color: #7df9ff; font-size: 22px; text-align: center;
            margin-bottom: 20px; border-bottom: 3px solid #4169e1;
            padding-bottom: 10px; letter-spacing: 1px;
        }
        
        #command-input {
            width: 100%; background: #000000; border: 2px solid #4169e1;
            color: #7df9ff; padding: 12px; border-radius: 8px;
            margin-bottom: 20px; font-size: 15px;
            outline: none; transition: all 0.3s;
        }
        
        #command-input:focus {
            border-color: #7df9ff; box-shadow: 0 0 15px #4169e1;
        }
        
        .command-list {
            max-height: 300px; overflow-y: auto; color: #7df9ff;
            font-size: 14px; padding-right: 5px;
        }
        
        .command-list::-webkit-scrollbar {
            width: 8px;
        }
        
        .command-list::-webkit-scrollbar-track {
            background: rgba(65, 105, 225, 0.1); border-radius: 4px;
        }
        
        .command-list::-webkit-scrollbar-thumb {
            background: #4169e1; border-radius: 4px;
        }
        
        .command-item {
            padding: 10px; margin: 8px 0; background: rgba(65, 105, 225, 0.1);
            border-radius: 8px; border-left: 4px solid #7df9ff;
            transition: all 0.2s;
        }
        
        .command-item:hover {
            background: rgba(65, 105, 225, 0.2);
            transform: translateX(5px);
        }
        
        /* STATUS MESSAGE */
        #status-message {
            position: fixed; bottom: 150px; left: 50%;
            transform: translateX(-50%); background: rgba(0, 0, 0, 0.95);
            border: 2px solid #4169e1; color: #7df9ff; padding: 15px 30px;
            border-radius: 10px; display: none; pointer-events: none;
            z-index: 200; font-size: 15px; text-align: center;
            box-shadow: 0 0 25px rgba(125, 249, 255, 0.6);
            backdrop-filter: blur(5px); min-width: 300px;
        }
        
        /* HACK OVERLAYS */
        #fullbright-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.2); pointer-events: none;
            z-index: 49; display: none;
        }
        
        #esp-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 50; display: none;
        }
        
        .esp-box {
            position: absolute; border: 2px solid #ff0000;
            background: rgba(255, 0, 0, 0.15); border-radius: 3px;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }
        
        .esp-label {
            position: absolute; color: #ff0000; font-size: 12px;
            font-weight: bold; text-shadow: 1px 1px 3px #000000;
            background: rgba(0, 0, 0, 0.7); padding: 2px 6px;
            border-radius: 3px; white-space: nowrap;
        }
        
        /* X-RAY OVERLAY */
        #xray-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7); pointer-events: none;
            z-index: 48; display: none;
        }
        
        /* WATERMARK */
        #watermark {
            position: absolute; top: 20px; right: 20px;
            color: rgba(125, 249, 255, 0.5); font-size: 12px;
            font-style: italic; pointer-events: none;
        }
    </style>
</head>
<body>
    <!-- LOADING SCREEN -->
    <div id="navine-loader">
        <div class="loader-logo">NAVINE CLIENT</div>
        <div class="loader-text">EAGLECRAFT 1.12 ENHANCED</div>
        <div class="loading-bar-container">
            <div class="loading-bar" id="loading-bar"></div>
        </div>
        <div id="loading-text" style="color: #7df9ff; margin-top: 25px; font-size: 16px;">Initializing...</div>
    </div>

    <!-- GAME CONTAINER -->
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        
        <!-- HACK OVERLAYS -->
        <div id="fullbright-overlay"></div>
        <div id="esp-overlay"></div>
        <div id="xray-overlay"></div>
        
        <!-- NAVINE UI -->
        <div id="navine-ui">
            <!-- HUD -->
            <div id="navine-hud">
                <div class="navine-title">NAVINE CLIENT</div>
                <div class="navine-stat">
                    <span class="navine-label">FPS:</span>
                    <span class="navine-value" id="hud-fps">60</span>
                </div>
                <div class="navine-stat">
                    <span class="navine-label">HACKS:</span>
                    <span class="navine-value" id="hud-hacks">0</span>
                </div>
                <div class="navine-stat">
                    <span class="navine-label">POS:</span>
                    <span class="navine-value" id="hud-pos">0, 64, 0</span>
                </div>
                <div id="hack-status">Status: Ready</div>
            </div>

            <!-- WATERMARK -->
            <div id="watermark">Navine Client v1.0</div>

            <!-- CONTROL BUTTONS -->
            <div id="control-buttons">
                <button class="control-btn" onclick="navine.toggleMenu()">MENU (R-SHIFT)</button>
                <button class="control-btn" onclick="navine.toggleCommands()">CMDS (.)</button>
            </div>

            <!-- HACK MENU -->
            <div id="hack-menu">
                <div class="menu-title">NAVINE HACKS</div>
                
                <div class="hack-category">
                    <div class="category-title">VISUALS</div>
                    <div class="hack-item" onclick="navine.toggleHack('fullbright')">
                        <span class="hack-name">Fullbright</span>
                        <span class="hack-key">N</span>
                        <div class="hack-toggle" id="toggle-fullbright"></div>
                    </div>
                    <div class="hack-item" onclick="navine.toggleHack('esp')">
                        <span class="hack-name">Player ESP</span>
                        <span class="hack-key">INSERT</span>
                        <div class="hack-toggle" id="toggle-esp"></div>
                    </div>
                    <div class="hack-item" onclick="navine.toggleHack('xray')">
                        <span class="hack-name">X-Ray Vision</span>
                        <span class="hack-key">X</span>
                        <div class="hack-toggle" id="toggle-xray"></div>
                    </div>
                </div>

                <div class="hack-category">
                    <div class="category-title">MOVEMENT</div>
                    <div class="hack-item" onclick="navine.toggleHack('flight')">
                        <span class="hack-name">Flight</span>
                        <span class="hack-key">F</span>
                        <div class="hack-toggle" id="toggle-flight"></div>
                    </div>
                    <div class="hack-item" onclick="navine.toggleHack('speed')">
                        <span class="hack-name">Speed Hack</span>
                        <span class="hack-key">R</span>
                        <div class="hack-toggle" id="toggle-speed"></div>
                    </div>
                    <div class="hack-item" onclick="navine.toggleHack('noclip')">
                        <span class="hack-name">No Clip</span>
                        <span class="hack-key">V</span>
                        <div class="hack-toggle" id="toggle-noclip"></div>
                    </div>
                </div>

                <div class="hack-category">
                    <div class="category-title">COMBAT</div>
                    <div class="hack-item" onclick="navine.toggleHack('killaura')">
                        <span class="hack-name">Kill Aura</span>
                        <span class="hack-key">K</span>
                        <div class="hack-toggle" id="toggle-killaura"></div>
                    </div>
                    <div class="hack-item" onclick="navine.toggleHack('reach')">
                        <span class="hack-name">Extended Reach</span>
                        <span class="hack-key">G</span>
                        <div class="hack-toggle" id="toggle-reach"></div>
                    </div>
                    <div class="hack-item" onclick="navine.toggleHack('triggerbot')">
                        <span class="hack-name">Trigger Bot</span>
                        <span class="hack-key">C</span>
                        <div class="hack-toggle" id="toggle-triggerbot"></div>
                    </div>
                </div>
            </div>

            <!-- COMMAND WINDOW -->
            <div id="command-window">
                <div class="command-header">NAVINE COMMANDS</div>
                <input type="text" id="command-input" placeholder="Type command (.help for list)" 
                       onkeypress="if(event.key==='Enter') navine.executeCommand(this.value); this.value='';">
                <div class="command-list">
                    <div class="command-item">.help - Show all commands</div>
                    <div class="command-item">.fly - Toggle flight mode</div>
                    <div class="command-item">.speed [1-10] - Set speed multiplier</div>
                    <div class="command-item">.esp - Toggle player ESP</div>
                    <div class="command-item">.xray - Toggle X-Ray vision</div>
                    <div class="command-item">.fullbright - Toggle fullbright</div>
                    <div class="command-item">.vclip [blocks] - Vertical teleport</div>
                    <div class="command-item">.tp [x y z] - Teleport to coordinates</div>
                    <div class="command-item">.heal - Full health restore</div>
                    <div class="command-item">.kill - Kill yourself</div>
                    <div class="command-item">.seed - Get world seed</div>
                    <div class="command-item">.time [day/night] - Set time</div>
                    <div class="command-item">.weather [clear/rain] - Set weather</div>
                    <div class="command-item">.noclip - Toggle no clip</div>
                    <div class="command-item">.killaura - Toggle kill aura</div>
                    <div class="command-item">.reach [3-10] - Set reach distance</div>
                    <div class="command-item">.tphere [player] - Teleport player to you</div>
                    <div class="command-item">.flyspeed [1-10] - Set fly speed</div>
                    <div class="command-item">.gamemode [0-3] - Change gamemode</div>
                </div>
            </div>

            <!-- STATUS MESSAGE -->
            <div id="status-message"></div>
        </div>
    </div>

    <script>
        // ============================================
        // NAVINE CLIENT CORE
        // ============================================
        class NavineClient {
            constructor() {
                this.hacks = {
                    fullbright: { enabled: false, category: 'visual', key: 'KeyN' },
                    esp: { enabled: false, category: 'visual', key: 'Insert' },
                    xray: { enabled: false, category: 'visual', key: 'KeyX' },
                    flight: { enabled: false, category: 'movement', key: 'KeyF' },
                    speed: { enabled: false, category: 'movement', key: 'KeyR', value: 2.0 },
                    noclip: { enabled: false, category: 'movement', key: 'KeyV' },
                    killaura: { enabled: false, category: 'combat', key: 'KeyK', range: 4.0 },
                    reach: { enabled: false, category: 'combat', key: 'KeyG', distance: 5.0 },
                    triggerbot: { enabled: false, category: 'combat', key: 'KeyC' }
                };
                
                this.activeHacks = new Set();
                this.fps = 60;
                this.gameRunning = false;
                this.playerPosition = { x: 0, y: 64, z: 0 };
                this.playerRotation = { yaw: 0, pitch: 0 };
                this.entities = [];
                this.worldTime = 6000; // Noon
                this.gameMode = 'survival';
                this.health = 20;
                this.hunger = 20;
                
                this.init();
            }

            init() {
                this.loadSettings();
                this.setupEventListeners();
                this.startFPSUpdate();
                this.startPositionUpdate();
                this.simulateLoading();
                this.generateTestEntities();
            }

            simulateLoading() {
                const bar = document.getElementById('loading-bar');
                const text = document.getElementById('loading-text');
                let progress = 0;
                
                const steps = [
                    'Initializing Navine Client...',
                    'Loading EagleCraft 1.12 Engine...',
                    'Setting up hack system...',
                    'Preparing render pipeline...',
                    'Loading world generator...',
                    'Initializing physics engine...',
                    'Setting up multiplayer bridge...',
                    'Loading assets...',
                    'Preparing user interface...',
                    'Starting game...'
                ];
                
                const interval = setInterval(() => {
                    progress += 10;
                    bar.style.width = `${progress}%`;
                    text.textContent = steps[Math.min(Math.floor(progress / 10), steps.length - 1)];
                    
                    if (progress >= 100) {
                        clearInterval(interval);
                        setTimeout(() => {
                            this.startGame();
                        }, 500);
                    }
                }, 200);
            }

            startGame() {
                document.getElementById('navine-loader').style.display = 'none';
                document.getElementById('game-container').style.display = 'block';
                this.gameRunning = true;
                
                this.startGameLoop();
                this.showStatus('Navine Client Ready! Press Right Shift for Menu');
                
                // Apply saved hacks
                for (const hack in this.hacks) {
                    if (this.hacks[hack].enabled) {
                        this.activateHack(hack);
                    }
                }
                this.updateHUD();
                
                // Initial game setup
                this.initializeWorld();
            }

            initializeWorld() {
                const canvas = document.getElementById('game-canvas');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                
                // Generate initial world state
                this.worldSeed = Math.floor(Math.random() * 1000000000);
                this.worldType = 'default';
                this.difficulty = 'normal';
                
                // Generate some initial entities
                this.generateTestEntities();
                
                // Start game systems
                this.startGameSystems();
            }

            generateTestEntities() {
                this.entities = [];
                // Add some test players
                for (let i = 0; i < 5; i++) {
                    this.entities.push({
                        type: 'player',
                        id: i,
                        name: `Player${i + 1}`,
                        position: {
                            x: this.playerPosition.x + (Math.random() - 0.5) * 50,
                            y: this.playerPosition.y,
                            z: this.playerPosition.z + (Math.random() - 0.5) * 50
                        },
                        rotation: {
                            yaw: Math.random() * 360,
                            pitch: 0
                        },
                        health: 20,
                        visible: true
                    });
                }
                
                // Add some mobs
                for (let i = 0; i < 3; i++) {
                    this.entities.push({
                        type: 'zombie',
                        id: 100 + i,
                        name: `Zombie${i + 1}`,
                        position: {
                            x: this.playerPosition.x + (Math.random() - 0.5) * 30,
                            y: this.playerPosition.y,
                            z: this.playerPosition.z + (Math.random() - 0.5) * 30
                        },
                        health: 20,
                        visible: true
                    });
                }
            }

            startGameSystems() {
                // Simulate entity movement
                setInterval(() => {
                    if (this.gameRunning) {
                        this.updateEntities();
                        if (this.hacks.esp.enabled) {
                            this.updateESP();
                        }
                    }
                }, 1000 / 20); // 20 Hz entity update
            }

            updateEntities() {
                this.entities.forEach(entity => {
                    // Simulate movement
                    if (entity.type === 'player' || entity.type === 'zombie') {
                        entity.position.x += (Math.random() - 0.5) * 0.5;
                        entity.position.z += (Math.random() - 0.5) * 0.5;
                        
                        // Simple physics
                        if (entity.position.y > 64) {
                            entity.position.y -= 0.1;
                        }
                    }
                });
            }

            startGameLoop() {
                const canvas = document.getElementById('game-canvas');
                const ctx = canvas.getContext('2d');
                
                const gameLoop = () => {
                    if (!this.gameRunning) return;
                    
                    // Update canvas size
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                    
                    // Clear canvas
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw sky gradient
                    const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height / 2);
                    skyGradient.addColorStop(0, '#1a237e');
                    skyGradient.addColorStop(1, '#000000');
                    ctx.fillStyle = skyGradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height / 2);
                    
                    // Draw ground
                    ctx.fillStyle = '#2e7d32';
                    ctx.fillRect(0, canvas.height / 2, canvas.width, canvas.height / 2);
                    
                    // Draw sun/moon based on time
                    this.drawCelestialBody(ctx);
                    
                    // Draw player
                    this.drawPlayer(ctx);
                    
                    // Draw entities if ESP is enabled
                    if (this.hacks.esp.enabled) {
                        this.drawEntities(ctx);
                    }
                    
                    // Draw HUD elements
                    this.drawHUD(ctx);
                    
                    // Draw crosshair
                    this.drawCrosshair(ctx);
                    
                    requestAnimationFrame(gameLoop);
                };
                
                gameLoop();
            }

            drawCelestialBody(ctx) {
                const canvas = document.getElementById('game-canvas');
                const time = this.worldTime % 24000;
                const isDay = time < 12000;
                
                const radius = 30;
                const x = canvas.width / 2 + Math.cos(time / 12000 * Math.PI * 2) * (canvas.width / 4);
                const y = canvas.height / 4 + Math.sin(time / 12000 * Math.PI * 2) * (canvas.height / 8);
                
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                
                if (isDay) {
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                    gradient.addColorStop(0, '#ffff00');
                    gradient.addColorStop(1, '#ffa500');
                    ctx.fillStyle = gradient;
                } else {
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(1, '#cccccc');
                    ctx.fillStyle = gradient;
                }
                
                ctx.fill();
            }

            drawPlayer(ctx) {
                const canvas = document.getElementById('game-canvas');
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                // Draw player body
                ctx.fillStyle = this.hacks.xray.enabled ? '#ff0000' : '#4169e1';
                ctx.fillRect(centerX - 15, centerY - 40, 30, 40);
                
                // Draw player head
                ctx.fillStyle = this.hacks.xray.enabled ? '#ff4444' : '#7df9ff';
                ctx.fillRect(centerX - 10, centerY - 60, 20, 20);
                
                // Draw health bar
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(centerX - 20, centerY - 70, 40, 5);
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(centerX - 20, centerY - 70, 40 * (this.health / 20), 5);
            }

            drawEntities(ctx) {
                const canvas = document.getElementById('game-canvas');
                
                this.entities.forEach(entity => {
                    if (!entity.visible) return;
                    
                    // Convert 3D position to 2D screen position
                    const screenX = canvas.width / 2 + (entity.position.x - this.playerPosition.x) * 10;
                    const screenY = canvas.height / 2 + (entity.position.z - this.playerPosition.z) * 10;
                    
                    // Check if entity is on screen
                    if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                        // Draw entity box
                        const color = entity.type === 'player' ? '#ff0000' : '#ff8800';
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 2;
                        ctx.strokeRect(screenX - 15, screenY - 40, 30, 40);
                        
                        // Draw name
                        ctx.fillStyle = color;
                        ctx.font = '12px monospace';
                        ctx.textAlign = 'center';
                        ctx.fillText(entity.name, screenX, screenY - 45);
                        
                        // Draw health
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(screenX - 15, screenY - 50, 30, 3);
                        ctx.fillStyle = '#00ff00';
                        ctx.fillRect(screenX - 15, screenY - 50, 30 * (entity.health / 20), 3);
                    }
                });
            }

            drawHUD(ctx) {
                const canvas = document.getElementById('game-canvas');
                
                // Draw hotbar
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(canvas.width / 2 - 91, canvas.height - 25, 182, 22);
                
                // Draw hotbar slots
                for (let i = 0; i < 9; i++) {
                    ctx.strokeStyle = '#4169e1';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(canvas.width / 2 - 90 + i * 20, canvas.height - 24, 18, 18);
                }
                
                // Draw selected slot
                ctx.strokeStyle = '#7df9ff';
                ctx.lineWidth = 3;
                ctx.strokeRect(canvas.width / 2 - 91 + 4 * 20, canvas.height - 25, 20, 22);
                
                // Draw health and hunger
                this.drawHealthHunger(ctx);
            }

            drawHealthHunger(ctx) {
                const canvas = document.getElementById('game-canvas');
                
                // Draw health hearts
                for (let i = 0; i < 10; i++) {
                    const x = 20 + i * 20;
                    const y = 20;
                    
                    ctx.fillStyle = '#ff0000';
                    if (this.health / 2 > i) {
                        ctx.beginPath();
                        ctx.moveTo(x + 8, y + 4);
                        ctx.bezierCurveTo(x + 8, y, x + 12, y, x + 12, y + 4);
                        ctx.bezierCurveTo(x + 12, y + 8, x + 8, y + 12, x + 8, y + 12);
                        ctx.bezierCurveTo(x + 8, y + 12, x + 4, y + 8, x + 4, y + 4);
                        ctx.bezierCurveTo(x + 4, y, x + 8, y, x + 8, y + 4);
                        ctx.fill();
                    }
                }
                
                // Draw hunger
                for (let i = 0; i < 10; i++) {
                    const x = 20 + i * 20;
                    const y = 45;
                    
                    ctx.fillStyle = '#ffa500';
                    if (this.hunger / 2 > i) {
                        ctx.beginPath();
                        ctx.moveTo(x + 4, y + 4);
                        ctx.lineTo(x + 12, y + 4);
                        ctx.lineTo(x + 16, y + 8);
                        ctx.lineTo(x + 12, y + 12);
                        ctx.lineTo(x + 4, y + 12);
                        ctx.lineTo(x, y + 8);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
            }

            drawCrosshair(ctx) {
                const canvas = document.getElementById('game-canvas');
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                
                // Draw crosshair
                ctx.beginPath();
                ctx.moveTo(centerX - 10, centerY);
                ctx.lineTo(centerX + 10, centerY);
                ctx.moveTo(centerX, centerY - 10);
                ctx.lineTo(centerX, centerY + 10);
                ctx.stroke();
                
                // Draw outer circle if extended reach is enabled
                if (this.hacks.reach.enabled) {
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 15, 0, Math.PI * 2);
                    ctx.strokeStyle = '#7df9ff';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }

            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    // Prevent default for hack keys
                    if (e.code === 'ShiftRight') {
                        e.preventDefault();
                        this.toggleMenu();
                        return;
                    }
                    
                    if (e.code === 'Period') {
                        e.preventDefault();
                        this.toggleCommands();
                        return;
                    }
                    
                    // Hack hotkeys
                    for (const [hack, data] of Object.entries(this.hacks)) {
                        if (e.code === data.key) {
                            e.preventDefault();
                            this.toggleHack(hack);
                            return;
                        }
                    }
                    
                    // Movement keys
                    if (['KeyW', 'KeyA', 'KeyS', 'KeyD', 'Space', 'ShiftLeft'].includes(e.code)) {
                        this.handleMovement(e.code, true);
                    }
                    
                    // Attack (left click simulation)
                    if (e.code === 'KeyQ') {
                        this.attack();
                    }
                    
                    // Jump
                    if (e.code === 'Space' && this.hacks.flight.enabled) {
                        this.flyUp();
                    }
                    
                    // Crouch/fly down
                    if (e.code === 'ShiftLeft' && this.hacks.flight.enabled) {
                        this.flyDown();
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    if (['KeyW', 'KeyA', 'KeyS', 'KeyD', 'Space', 'ShiftLeft'].includes(e.code)) {
                        this.handleMovement(e.code, false);
                    }
                });
                
                // Mouse movement
                document.addEventListener('mousemove', (e) => {
                    if (this.gameRunning) {
                        this.playerRotation.yaw += e.movementX * 0.2;
                        this.playerRotation.pitch -= e.movementY * 0.2;
                        this.playerRotation.pitch = Math.max(-90, Math.min(90, this.playerRotation.pitch));
                    }
                });
                
                // Mouse click for attack
                document.addEventListener('mousedown', (e) => {
                    if (e.button === 0 && this.gameRunning) { // Left click
                        this.attack();
                    }
                });
                
                // Window resize
                window.addEventListener('resize', () => {
                    if (this.gameRunning) {
                        const canvas = document.getElementById('game-canvas');
                        canvas.width = window.innerWidth;
                        canvas.height = window.innerHeight;
                    }
                });
            }

            handleMovement(key, isPressed) {
                const moveSpeed = this.hacks.speed.enabled ? this.hacks.speed.value * 0.1 : 0.1;
                
                if (isPressed) {
                    switch(key) {
                        case 'KeyW':
                            this.playerPosition.x += Math.sin(this.playerRotation.yaw * Math.PI / 180) * moveSpeed;
                            this.playerPosition.z -= Math.cos(this.playerRotation.yaw * Math.PI / 180) * moveSpeed;
                            break;
                        case 'KeyS':
                            this.playerPosition.x -= Math.sin(this.playerRotation.yaw * Math.PI / 180) * moveSpeed;
                            this.playerPosition.z += Math.cos(this.playerRotation.yaw * Math.PI / 180) * moveSpeed;
                            break;
                        case 'KeyA':
                            this.playerPosition.x += Math.sin((this.playerRotation.yaw - 90) * Math.PI / 180) * moveSpeed;
                            this.playerPosition.z -= Math.cos((this.playerRotation.yaw - 90) * Math.PI / 180) * moveSpeed;
                            break;
                        case 'KeyD':
                            this.playerPosition.x += Math.sin((this.playerRotation.yaw + 90) * Math.PI / 180) * moveSpeed;
                            this.playerPosition.z -= Math.cos((this.playerRotation.yaw + 90) * Math.PI / 180) * moveSpeed;
                            break;
                        case 'Space':
                            if (!this.hacks.flight.enabled) {
                                this.playerPosition.y += 0.5;
                            }
                            break;
                    }
                }
                
                // Update HUD position display
                this.updateHUD();
            }

            flyUp() {
                if (this.hacks.flight.enabled) {
                    this.playerPosition.y += 0.5;
                }
            }

            flyDown() {
                if (this.hacks.flight.enabled && this.playerPosition.y > 0) {
                    this.playerPosition.y -= 0.5;
                }
            }

            attack() {
                if (this.hacks.killaura.enabled) {
                    // Auto-attack nearby entities
                    this.entities.forEach(entity => {
                        const distance = Math.sqrt(
                            Math.pow(entity.position.x - this.playerPosition.x, 2) +
                            Math.pow(entity.position.z - this.playerPosition.z, 2)
                        );
                        
                        if (distance < this.hacks.killaura.range) {
                            entity.health -= 2;
                            if (entity.health <= 0) {
                                entity.visible = false;
                                this.showStatus(`Killed ${entity.name}!`);
                            }
                        }
                    });
                } else if (this.hacks.triggerbot.enabled) {
                    // Auto-attack when looking at entity
                    const target = this.getEntityInCrosshair();
                    if (target) {
                        target.health -= 2;
                        if (target.health <= 0) {
                            target.visible = false;
                            this.showStatus(`Killed ${target.name}!`);
                        }
                    }
                }
                
                // Normal attack
                this.showStatus('Attack!', 500);
            }

            getEntityInCrosshair() {
                // Simple entity detection
                for (const entity of this.entities) {
                    const distance = Math.sqrt(
                        Math.pow(entity.position.x - this.playerPosition.x, 2) +
                        Math.pow(entity.position.z - this.playerPosition.z, 2)
                    );
                    
                    if (distance < (this.hacks.reach.enabled ? this.hacks.reach.distance : 3)) {
                        return entity;
                    }
                }
                return null;
            }

            toggleHack(hackName) {
                if (!this.hacks[hackName]) return;
                this.hacks[hackName].enabled = !this.hacks[hackName].enabled;
                
                const toggle = document.getElementById(`toggle-${hackName}`);
                if (toggle) toggle.classList.toggle('active');
                
                if (this.hacks[hackName].enabled) {
                    this.activeHacks.add(hackName);
                    this.activateHack(hackName);
                } else {
                    this.activeHacks.delete(hackName);
                    this.deactivateHack(hackName);
                }
                
                this.updateHUD();
                this.saveSettings();
                this.showStatus(`${hackName.toUpperCase()} ${this.hacks[hackName].enabled ? 'ENABLED' : 'DISABLED'}`);
            }

            activateHack(hackName) {
                switch(hackName) {
                    case 'fullbright':
                        document.getElementById('fullbright-overlay').style.display = 'block';
                        break;
                    case 'esp':
                        document.getElementById('esp-overlay').style.display = 'block';
                        this.updateESP();
                        break;
                    case 'xray':
                        document.getElementById('xray-overlay').style.display = 'block';
                        break;
                    case 'flight':
                        this.showStatus('Flight Enabled - SPACE: Up, SHIFT: Down');
                        break;
                    case 'speed':
                        this.showStatus(`Speed ${this.hacks.speed.value}x Enabled`);
                        break;
                    case 'noclip':
                        this.showStatus('No Clip Enabled - Walk through blocks');
                        break;
                    case 'killaura':
                        this.showStatus(`Kill Aura Active (${this.hacks.killaura.range} blocks)`);
                        break;
                    case 'reach':
                        this.showStatus(`Extended Reach (${this.hacks.reach.distance} blocks)`);
                        break;
                    case 'triggerbot':
                        this.showStatus('Trigger Bot Active - Auto-attack on sight');
                        break;
                }
            }

            deactivateHack(hackName) {
                switch(hackName) {
                    case 'fullbright':
                        document.getElementById('fullbright-overlay').style.display = 'none';
                        break;
                    case 'esp':
                        document.getElementById('esp-overlay').style.display = 'none';
                        document.getElementById('esp-overlay').innerHTML = '';
                        break;
                    case 'xray':
                        document.getElementById('xray-overlay').style.display = 'none';
                        break;
                }
            }

            updateESP() {
                const overlay = document.getElementById('esp-overlay');
                overlay.innerHTML = '';
                
                this.entities.forEach(entity => {
                    if (!entity.visible) return;
                    
                    // Convert 3D position to 2D screen position
                    const screenX = window.innerWidth / 2 + (entity.position.x - this.playerPosition.x) * 10;
                    const screenY = window.innerHeight / 2 + (entity.position.z - this.playerPosition.z) * 10;
                    
                    if (screenX >= 0 && screenX <= window.innerWidth && screenY >= 0 && screenY <= window.innerHeight) {
                        const box = document.createElement('div');
                        box.className = 'esp-box';
                        box.style.left = `${screenX - 15}px`;
                        box.style.top = `${screenY - 40}px`;
                        box.style.width = '30px';
                        box.style.height = '40px';
                        overlay.appendChild(box);
                        
                        const label = document.createElement('div');
                        label.className = 'esp-label';
                        label.style.left = `${screenX}px`;
                        label.style.top = `${screenY - 50}px`;
                        label.textContent = `${entity.name} (${Math.floor(entity.health)}â¤)`;
                        label.style.transform = 'translateX(-50%)';
                        overlay.appendChild(label);
                    }
                });
            }

            executeCommand(cmd) {
                const parts = cmd.split(' ');
                const baseCmd = parts[0].toLowerCase();
                const args = parts.slice(1);

                const commands = {
                    '.help': () => this.showStatus('Commands: .fly .speed .esp .xray .fullbright .vclip .tp .heal .kill .seed .time .weather .noclip .killaura .reach .tphere .flyspeed .gamemode'),
                    '.fly': () => this.toggleHack('flight'),
                    '.speed': () => {
                        if (args.length > 0) {
                            const speed = parseFloat(args[0]);
                            if (speed >= 1 && speed <= 10) {
                                this.hacks.speed.value = speed;
                                this.showStatus(`Speed set to ${speed}x`);
                            }
                        }
                        this.toggleHack('speed');
                    },
                    '.esp': () => this.toggleHack('esp'),
                    '.xray': () => this.toggleHack('xray'),
                    '.fullbright': () => this.toggleHack('fullbright'),
                    '.vclip': () => {
                        if (args.length > 0) {
                            const blocks = parseFloat(args[0]);
                            this.playerPosition.y += blocks;
                            this.showStatus(`V-Clipped ${blocks} blocks`);
                        }
                    },
                    '.tp': () => {
                        if (args.length >= 3) {
                            this.playerPosition.x = parseFloat(args[0]);
                            this.playerPosition.y = parseFloat(args[1]);
                            this.playerPosition.z = parseFloat(args[2]);
                            this.showStatus(`Teleported to ${args[0]}, ${args[1]}, ${args[2]}`);
                        }
                    },
                    '.heal': () => {
                        this.health = 20;
                        this.hunger = 20;
                        this.showStatus('Health and hunger restored!');
                    },
                    '.kill': () => {
                        this.health = 0;
                        this.showStatus('You died!');
                        setTimeout(() => {
                            this.health = 20;
                            this.playerPosition = { x: 0, y: 64, z: 0 };
                            this.showStatus('Respawned');
                        }, 2000);
                    },
                    '.seed': () => {
                        this.showStatus(`World Seed: ${this.worldSeed}`);
                    },
                    '.time': () => {
                        if (args.length > 0) {
                            if (args[0] === 'day') this.worldTime = 1000;
                            else if (args[0] === 'night') this.worldTime = 13000;
                            this.showStatus(`Time set to ${args[0]}`);
                        }
                    },
                    '.weather': () => {
                        if (args.length > 0) {
                            this.showStatus(`Weather set to ${args[0]}`);
                        }
                    },
                    '.noclip': () => this.toggleHack('noclip'),
                    '.killaura': () => this.toggleHack('killaura'),
                    '.reach': () => {
                        if (args.length > 0) {
                            const reach = parseFloat(args[0]);
                            if (reach >= 3 && reach <= 10) {
                                this.hacks.reach.distance = reach;
                                this.showStatus(`Reach set to ${reach} blocks`);
                            }
                        }
                        this.toggleHack('reach');
                    },
                    '.tphere': () => {
                        if (args.length > 0) {
                            this.showStatus(`Teleported ${args[0]} to your location`);
                        }
                    },
                    '.flyspeed': () => {
                        if (args.length > 0) {
                            const speed = parseFloat(args[0]);
                            this.showStatus(`Fly speed set to ${speed}`);
                        }
                    },
                    '.gamemode': () => {
                        if (args.length > 0) {
                            const modes = ['survival', 'creative', 'adventure', 'spectator'];
                            if (args[0] >= 0 && args[0] <= 3) {
                                this.gameMode = modes[args[0]];
                                this.showStatus(`Gamemode set to ${this.gameMode}`);
                            }
                        }
                    }
                };

                if (commands[baseCmd]) {
                    commands[baseCmd]();
                } else {
                    this.showStatus(`Unknown command: ${baseCmd}`);
                }
            }

            toggleMenu() {
                const menu = document.getElementById('hack-menu');
                menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
            }

            toggleCommands() {
                const window = document.getElementById('command-window');
                window.style.display = window.style.display === 'block' ? 'none' : 'block';
                if (window.style.display === 'block') {
                    document.getElementById('command-input').focus();
                }
            }

            updateHUD() {
                const activeCount = this.activeHacks.size;
                document.getElementById('hud-hacks').textContent = activeCount;
                document.getElementById('hud-fps').textContent = this.fps;
                document.getElementById('hud-pos').textContent = 
                    `${Math.floor(this.playerPosition.x)}, ${Math.floor(this.playerPosition.y)}, ${Math.floor(this.playerPosition.z)}`;
                
                let status = 'Ready';
                if (activeCount > 0) {
                    status = `${activeCount} Hacks Active`;
                    document.getElementById('hack-status').style.color = '#00ff00';
                } else {
                    document.getElementById('hack-status').style.color = '#7df9ff';
                }
                document.getElementById('hack-status').textContent = status;
            }

            showStatus(text, duration = 2000) {
                const msg = document.getElementById('status-message');
                msg.textContent = text;
                msg.style.display = 'block';
                setTimeout(() => { msg.style.display = 'none'; }, duration);
            }

            startFPSUpdate() {
                let frames = 0;
                let lastTime = performance.now();

                const updateFPS = () => {
                    frames++;
                    const currentTime = performance.now();
                    
                    if (currentTime - lastTime >= 1000) {
                        this.fps = Math.round((frames * 1000) / (currentTime - lastTime));
                        this.updateHUD();
                        frames = 0;
                        lastTime = currentTime;
                    }
                    
                    requestAnimationFrame(updateFPS);
                };
                
                updateFPS();
            }

            startPositionUpdate() {
                setInterval(() => {
                    this.updateHUD();
                }, 100);
            }

            saveSettings() {
                const settings = {};
                for (const [hack, data] of Object.entries(this.hacks)) {
                    settings[hack] = data.enabled;
                }
                localStorage.setItem('navine-hacks', JSON.stringify(settings));
            }

            loadSettings() {
                try {
                    const saved = localStorage.getItem('navine-hacks');
                    if (saved) {
                        const settings = JSON.parse(saved);
                        for (const [hack, enabled] of Object.entries(settings)) {
                            if (this.hacks[hack]) {
                                this.hacks[hack].enabled = enabled;
                                if (enabled) {
                                    this.activeHacks.add(hack);
                                    const toggle = document.getElementById(`toggle-${hack}`);
                                    if (toggle) toggle.classList.add('active');
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.log('No saved settings');
                }
            }
        }

        // ============================================
        // INITIALIZE NAVINE CLIENT
        // ============================================
        const navine = new NavineClient();
        
        // Enable fullscreen click
        document.addEventListener('click', () => {
            const canvas = document.getElementById('game-canvas');
            if (document.pointerLockElement !== canvas) {
                canvas.requestPointerLock();
            }
        });
        
        // Handle escape key for pointer lock
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Escape') {
                document.exitPointerLock();
            }
        });
    </script>
</body>
</html>
